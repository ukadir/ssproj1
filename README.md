# C++ Starter Project for CSE100

This entire README is a üõ† Know Your Tools section.

‚ÑπÔ∏è Before continuing, make sure you have either opened the project in a devcontainer, on codespaces, on ieng6, or have all required tools installed on your machine. Check the [SETUP.md](SETUP.md) document if you are unsure about which tools you need.

‚ÑπÔ∏è The commands you can run in this project are listed in [COMMANDS_CHEATSHEET.md](COMMANDS_CHEATSHEET.md)


## Building (Compiling And Running Executables)

- This project uses the `CMake` build configuration system which will automatically generate `Makefiles`. You can find more information on `CMake` here: https://cmake.org/ and here: https://cliutils.gitlab.io/modern-cmake/. 
- To initialize the build setup using CMake, first create a build directory `mkdir build` and cd into it `cd build`. Then run `cmake ..` to generate the Makefiles.  
‚ö†Ô∏èNOTE: Only run the `cmake ..` command from inside your build directory. Do not try to run `cmake .` in your project root, because this will clutter your project with autogenerated build files.
- You can now build all executables of your project by running `make` inside your build directory.
- To compile a single executable after build setup, type: `make name-of-the-executable` as it appears in the `Makefile`.
- All the src executables are under `./build/src/`.
- All the test executables are under `./build/test/`.
- (Take a look at the `CMakeLists.txt` files in the project root, src and test directories to understand how the build process works.)

### CMake and CTest recap
For a CTest refresher, you can refer to the [Know Your Tools - CTest](https://github.com/UCSD-CSE100-SS1-2020/PA3-Starter/blob/master/README.md#-know-your-tools---ctest) section in PA3.

After building your test executables, you can run:
- a single test by running its executable, located in `./build/test/`
- a single test with the command `ctest -R <name of test>`
   - the `-R` option runs all test cases matching the regular expression following it. You do not need to know what a regular expression is, all you need to know is that if you follow `-R` with the name of the test, only that test will be run. You can see more of the `ctest` options [here](https://cmake.org/cmake/help/latest/manual/ctest.1.html#options).
- all tests with the command `make test`
- all tests with the command `ctest`
#### Adding Libraries
You may remember using the `add_executable` build rule from [PA4](https://github.com/UCSD-CSE100-SS1-2020/PA4-starter#-know-your-tools---cmake). In this project, you will also see these build rules in some of the CMakeLists.txt files:
- [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html)
- [`target_include_directories`](https://cmake.org/cmake/help/latest/command/target_include_directories.html)
- [`target_link_libraries`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html)

You can see each of their respective documentation by clicking on them above.


When running `uncompress` and `decompress`, you may notice they can take different command line options.
### CXXOPTS
The cxxopts libary makes it easy to parse C++ command line arguments\.
In `./src/compress.cpp` and `./src/uncompress.cpp` cxxopts has already been utilized with `ascii`, `input`, `output`, and `help` options. 

[Here](https://github.com/jarro2783/cxxopts/blob/master/src/example.cpp) is an example of cxxopts being used. You can read more about cxxopts [here](https://github.com/jarro2783/cxxopts/wiki/)


## Testing

To run your tests you first have to build your project. See the section above on how to do that.
If you have compiled your project, you can run all the tests by running `make test` from within the build directory.

You can run a single test like so: `./build/test/path/file-name`

### GoogleTest
The GoogleTest framework allows you write unit tests for your code. Test files are under the `test/` directory in this project. To write a test, use the `TEST` macro:
```cpp
TEST(SuiteName, TestName) {
    // Test code goes here
}
```
#### Assert Statements
The GoogleTest framework uses assertions to determine whether a test has passed or failed. For instance, here are some of the assertions available:
- `ASSERT_EQ(val1, val2)` - Fails the test if the two values are not the same (note: this uses the `==` operator, so for pointers, it looks for pointer equality instead of equality between the two underlying objects).
- `ASSERT_NE(val1, val2)` - Fails the test if the two values are the same.
- `ASSERT_GT(val1, val2)` - Fails the test if `val1 <= val2`.
- `ASSERT_GE(val1, val2)` - Fails the test if `val1 < val2`
- `ASSERT_LT(val1, val2)` - Fails the test if `val1 >= val2`
- `ASSERT_LE(val1, val2)` - Fails the test if `val1 val2`
>
There can be multiple assert statements in a test. In order for a test to pass, all the assert statements in that test must succeed.
>
You can learn more about writing tests from the [GoogleTest documentation](https://github.com/google/googletest/blob/master/googletest/docs/primer.md).
>
If you want to add a new C++ file with tests, you will also have to update the corresponding `CMakeLists.txt` file in order to compile the test file.
#### Fixtures
To set up your tests, you can utilize [fixtures](https://github.com/google/googletest/blob/master/googletest/docs/primer.md#test-fixtures-using-the-same-data-configuration-for-multiple-tests-same-data-multiple-tests). A fixture allows you to reuse an object configuration for multiple tests; this way, you do not need to create the same objects multiple times for multiple tests.
In the starter code, you can see a test fixture class is declared on line 12 of `./test/test_HCTree.cpp`:
```cpp
class SimpleHCTreeFixture : public ::testing::Test {
  protected:
    HCTree tree;

  public:
    SimpleHCTreeFixture() {
        // initialization code here
        vector<unsigned intfreqs(256);
        freqs['a'] = 2;
        freqs['b'] = 3;
        tree.build(freqs);
    }
};
```
`tree` can be used in any of the tests in `test_HCTree.cpp`, as long as the `TEST_F` macro is used.

On line 26 in `test_HCTree.cpp`, the `TEST_F` macro is used to define a test, instead of the macro `TEST`. The first argument is still the test suite name, but since we want to use a fixture, it must be the name of the test fixture class - in this case `SimpleHCTreeFixture`:
```cpp
TEST_F(SimpleHCTreeFixture, TEST_ENCODE)
```
From the [documention](https://github.com/google/googletest/blob/master/googletest/docs/primer.md#test-fixtures-using-the-same-data-configuration-for-multiple-tests-same-data-multiple-tests):
```
"For each test defined with TEST_F(), googletest will create a fresh test fixture at runtime"
```
This means that each instance of a fixture is independent from other instances of it, so if it is modified in one test case, those modifications are not reflected in another test case.

### Code Coverage

Calculating code coverage is a way of measuring the quality of your test suite. 
A code coverage report shows the lines of code that were executed by your tests. 
This will give you insight into the weaknesses in your test suite as you can easily see which lines of code are not yet tested.

You can generate a code coverage report of your tests by running:
`make cov` from within the `build` directory.
The coverage report should appear under `build/code_coverage`. You can open `index.html` in your browser to see the full report.

If you are ssh'd into ieng6, you will need to download the coverage report to your computer first before you can open it in a browser.

## Tools for Code Quality

This project includes numerous tools that can help you make sure that the quality of your code is on par.

### Auto Formatting

If you're working in a devcontainer, you may already have noticed that the code gets autoformatted when you save. This project is using `clang-format` to achieve that (see documentation [here](https://clang.llvm.org/docs/ClangFormatStyleOptions.html)).
On ieng6, you'll have to run `clang-format` yourself.

To run `clang-format` on the entire project run:
`make format` from within the `build` directory.

### Static Analysis

Static analysis tools parse your source code for possible causes of bugs and violations of code style rules.
They will notify you of suspicious looking code that may have a bug in it.

This project supports the following static analyzers:

- `make cppcheck`
- `make scan-build`

### Dynamic Analysis

Dynamic analysis tools do not parse the source code, but execute the compiled files. This project supports `Valgrind`.

- `valgrind build/path/to/the/executable_file`

## Debugging

Both the devcontainer and ieng6 come with gdb installed and by default all source files are compiled with debugging support enabled. 

You can run gdb like this: `gdb build/path/to/the/executable_file`

Try debugging main and then try debugging a test.

### Debugging in the devcontainer

In the devcontainer we've also included 2 debugging tasks in the VSCode setup.
Click the debug window icon on the left or use the short cut ctrl+shift+d (cmd+shift+d on mac).
You can see the following debug tasks:
![Debug](images/debug.png "Debug")

You can run the debug task by clicking the green play icon.

Alternatively, you can press F5 to run the currently selected debug task.

‚ö†Ô∏èNOTE: The "debug active file" task will not work if your active file cannot be compiled to an executable. In case of an error look at the corresponding `CMakeLists.txt` to make sure that the file you are trying to debug is being compiled into an executable.

You can create breakpoints by clicking left of the line numbers in VSCode.

### `xxd` and `hexdump`
`xxd` can create a hexdump and also convert a hex dump back to binary form. See the [documentation](https://linux.die.net/man/1/xxd) for more information.

`hexdump` can be used to display files in different forms. See the [documentation](https://linux.die.net/man/1/hexdump) for more information.
